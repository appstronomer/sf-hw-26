# Реализация шаблона пайплайна
Данный репозиторий дополняет является сочетанием двух практических работ: реализация шаблона пайплайна; практика по основам Linux, Git и Docker.

## Запуск
Для удобства ввода данных через stdin создан файл stdin.txt, который можно передать построчно в запускаемый процесс:
```sh
go run main.go < ./inout/stdin.txt 1> ./inout/stdout.txt 2> ./inout/stderr.txt
```
Можно так же собрать docker-образ и запустить приложение из контейнера:
```sh
docker build -t sf-hw-26 . && docker run --rm -v ./inout/:/root/inout/ sf-hw-26
```

## Детали реализации

### Pipe
Абстракция конвейера расположена в пакете "github.com/appstronomer/sf-hw-26/pipe". Это структура-строитель, размещающая отдельные функции в цепочку горутин, соединенных каналами. Я использую её для того, чтобы не контролировать создание и закрытие каналов внутри функций с бизнес-логикой. Информацию о завершении работы конвейера я передаю через WaitGroup из последней горутины в цепочке. Информацию о завершении предыдущих горутин я передаю закрытием канала.

### Ring
Кольцевой буфер расположен в пакете "github.com/appstronomer/sf-hw-26/ring". Я не уверен, что понял запрос на реализацию интерфейса, который был дан в задании модуля 19, поэтому, как всегда объясню своё понимание этого требования. Интерфейс каждого актора в задании модуля 19 - это функция-объект с настроечными данными в её замыкании. Поэтому я реализовал создание кольцевого буфера в виде функции, возвращающей функцию-объект, которая: во-первых в замыкании имеет конфигурацию размера буфера из агрумента внешней функции; во-вторых реализует интерфейс, необходимый для передачи этой функции в метод pipe.Next(). На курсе алгоритмов я уже реализовывал объектно-ориентированную очередь на базе кольцевого буфера, которая решение о наличии в ней элементов принимает на оснвое дополнительного поля - количества элементов. В этот раз я реализовал кольцевой буфер, не использующий дополнительные поля и переменные, а решение о наличии элементов принимающий на основе взаимного расположения индексов первого и последнего элемента. Получилось очень "алгоритмично" - поэтому реализовал несколько юнит-тестов для этого пакета. Суть самого буфера следующая: пока есть место буфер принимает от предыдущей горутины сообщения и по возможности отправляет их следующей горутине. Если буфер переполняется, то самые старые сообщения перезаписываются самыми новыми - я полагаю, что главная задача буфера заключается в доставке самых актуальных сообщений в количестве, не меньшем, чем размер буфера. Если предыдущая горутина закроет канал, то буфер отдаст все сохраненные сообщения, и только потом остановится.

### Input/output
Ввод и вывод. loopStdin читает построчно текст из stdin и пытается привести его к числам, сообщая в stderr о неудачах с префиксом "ERR" и о успехах с префиксом "LOG". loopStdout выводит каждое число в stdout в виде текста. Канал stderr обернут в log.Logger, т.к. к нему обращаются и другие горутины. loopStdout не имеет встроенных лагов и задержек, этот функционал я вывел в отдельное звено конвейера, чтобы разделить ответственность за разные функции между разными функциями.

### Intentional lags
Диверсии с лагами создаёт loopSabotage. Он пропускает первые 50 сообщений без задержек, а все остальные отправляет с задержкой в 5 мс. Его я ставлю после буфера, но до вывода, чтобы заставить буфер работать.

### Filtering
Фильтрация ведется двумя функциями: loopFilterNegative и loopFilterMul. Если фильтр не пропускает число дальше, то он сообщает об этом в stderr с префиксом "FILTER".